# Интерфейсы
## IVector

Интерфейс для вектора - элемент n-мерного евклидова пространства.

Реализация вектора должна быть подобна массиву примитивов - один непрерывный блок памяти содержащий элементы вектора и метаинформацию о векторе.
Размер блока клиентский код должен иметь возможность получить из метода `sizeAllocated`.

Аксиомы типа:
- элементы не могут быть NaN, Inf, -Inf
- размерность пространства, которому принадлежит вектор, не может быть 0

Замечания по интерфейсу:
- метод `copyInstance` выполняет копирование данных из одного экземпляра вектора в другой
- метод `moveInstance` выполняет копирование данных из одного экземпляра вектора в другой и уничтожает источник данных (move семантика)
- логгер должен быть единственный на все вектора
- метод `inc` метод выполняет операцию приращения (increment), аналогично `dec` (decrement)
- методы `add` и `sub` создают новый вектор
- метод `dot` (dot product) - скалярное произведение
- метод `applyFunction` изменяет вектор: каждый элемент преобразуется согласно переданной функции (el = fun(el))
- метод `foreach` применяет функцию к каждому элементу вектора
- деструктор чисто виртуальный намеренно, чтобы подчеркунть абстарктность типа `IVector`
- токен `NORM::AMOUNT` означает количество норм в перечислении

## ISet

Интерфейс для контейнера - множества векторов, которые хранятся в хронологической последовательности.

Изменение размера контейнера при нехватке выделенной памяти выполняем скрыто от клиентского кода во время выполнения метода `insert`. В связи с реалокациями не можем хранить реализацию интерфейса в виде единого блока памяти (как в случае с вектором), но сами вектора хранящиеся в контейнере - можем.
Опять же в связи с реалокациями скрытыми от пользователя, не можем возвращать shallow копии векторов - получение ресурса сопровождается созданием нового вектора (касается методов `get`, `findFirst`, метода `get` итератора).

Замечания по интерфейсу:
- деструктор чисто виртуальный намеренно, аналогично `IVector`
