# Интерфейсы
## IVector

[Интерфейс](https://github.com/ThinkingFrog/IVector/blob/main/include/IVector.h) для вектора - элемент n-мерного евклидова пространства.

Реализация вектора должна быть подобна массиву примитивов - один непрерывный блок памяти содержащий элементы вектора и метаинформацию о векторе.
Размер блока клиентский код должен иметь возможность получить из метода `sizeAllocated`.

Аксиомы типа:
- элементы не могут быть NaN, Inf, -Inf
- размерность пространства, которому принадлежит вектор, не может быть 0

Аксиомы должны выполняться в любой момент времени, после выполнения любой операции над вектором.

Замечания по интерфейсу:
- метод `copyInstance` выполняет копирование данных из одного экземпляра вектора в другой, который в общем случае может не является валидным вектором (указатель может быть получен `reinterpret_cast'ом`)
- метод `moveInstance` выполняет копирование данных из одного экземпляра вектора в другой и уничтожает источник данных (move семантика)
- факт того, что тип реализует опреации `copyInstance`, `moveInstance` говорит о том, что экземпляры этого типа можно копировать и перемещать как сырую память размером `sizeAllocated` байтов.
- логгер предполагается держать глабально в библиотеке (поэтому передаём статическим методом)
- метод `inc` метод выполняет операцию приращения (increment), аналогично `dec` (decrement)
- методы `add` и `sub` создают новый вектор
- метод `dot` (dot product) - скалярное произведение
- метод `applyFunction` изменяет вектор: каждый элемент преобразуется согласно переданной функции (el = fun(el))
- метод `foreach` применяет функцию к каждому элементу вектора
- деструктор чисто виртуальный намеренно, чтобы подчеркунть абстарктность типа `IVector`
- токен `NORM::AMOUNT` означает количество норм в перечислении

## ISet

[Интерфейс](https://github.com/ThinkingFrog/IVector/blob/main/include/ISet.h) для контейнера - множество векторов, которые хранятся в хронологической последовательности.

Изменение размера контейнера при нехватке выделенной памяти выполняем скрыто от клиентского кода во время выполнения метода `insert`. В связи с реалокациями не можем хранить реализацию интерфейса в виде единого блока памяти (как в случае с вектором), но сами вектора хранящиеся в контейнере - можем.

Опять же в связи с реалокациями скрытыми от пользователя, не можем возвращать shallow копии векторов - получение ресурса сопровождается созданием нового вектора или копированием данных в некоторый буфферный вектор (касается методов `get...`, `findFirst...`, метода `get...` итератора).

Замечания по интерфейсу:
- методы для получения элемента `ISet` имеют 2 варианта по семантике получения ресурса: получение нового объекта (`getCopy`) и запись значений в полученный буфферный вектор  (`getCoords`). Аналогично для итератора.
- деструктор чисто виртуальный намеренно, аналогично `IVector`
