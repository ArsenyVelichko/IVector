# Интерфейсы
## IVector

[Интерфейс для вектора](https://github.com/ThinkingFrog/IVector/blob/main/include/IVector.h) - элемент n-мерного евклидова пространства.

Реализация вектора должна быть подобна массиву примитивов - один непрерывный блок памяти содержащий элементы вектора и метаинформацию о векторе.
Размер блока клиентский код должен иметь возможность получить из метода `sizeAllocated`.

Аксиомы типа:
- элементы не могут быть NaN, Inf, -Inf
- размерность пространства, которому принадлежит вектор, не может быть 0

Аксиомы должны выполняться в любой момент времени, после выполнения любой операции над вектором.

Замечания по интерфейсу:
- метод `copyInstance` выполняет копирование данных из одного экземпляра вектора в другой, который в общем случае может не является валидным вектором (указатель может быть получен `reinterpret_cast'ом`)
- метод `moveInstance` выполняет копирование данных из одного экземпляра вектора в другой и уничтожает источник данных (move семантика)
- факт того, что тип реализует опреации `copyInstance`, `moveInstance` говорит о том, что экземпляры этого типа можно копировать и перемещать как сырую память размером `sizeAllocated` байтов.
- логгер предполагается держать глабально в библиотеке (поэтому передаём статическим методом)
- метод `inc` выполняет операцию приращения (increment), аналогично `dec` (decrement)
- методы `add` и `sub` создают новый вектор
- метод `dot` (dot product) - скалярное произведение
- метод `applyFunction` изменяет вектор: каждый элемент преобразуется согласно переданной функции (el = fun(el))
- метод `foreach` применяет функцию к каждому элементу вектора (fun(el))
- деструктор чисто виртуальный намеренно, чтобы подчеркунть абстарктность типа `IVector`
- токен `NORM::AMOUNT` означает количество норм в перечислении

## ISet

[Интерфейс для контейнера - множество векторов](https://github.com/ThinkingFrog/IVector/blob/main/include/ISet.h), которые хранятся в хронологической последовательности.

Изменение размера контейнера при нехватке выделенной памяти выполняем скрыто от клиентского кода во время выполнения метода `insert`. В связи с реалокациями не можем хранить реализацию интерфейса в виде единого блока памяти (как в случае с вектором), но сами вектора хранящиеся в контейнере - можем.

Опять же в связи с реалокациями скрытыми от пользователя, не можем возвращать shallow копии векторов - получение ресурса сопровождается созданием нового вектора или копированием данных в некоторый буфферный вектор (касается методов `get...`, `findFirst...`, метода `get...` итератора).

Замечания по интерфейсу:
- методы для получения элемента `ISet` имеют 2 варианта по семантике получения ресурса: получение нового объекта (`getCopy`) и запись значений в полученный буфферный вектор  (`getCoords`). Аналогично для итератора
- деструктор чисто виртуальный намеренно, аналогично `IVector`

## ICompact

[Интерфейс для n-мерного замкнутого параллелепипеда - компакта](https://github.com/ThinkingFrog/IVector/blob/main/include/ICompact.h) в n-мерном евклидовом пространстве.

Фактически представляет собой сетку, которая заданна двумя векторами, содержащими информацию о границах параллелепипеда, и вектором с целочисленными компонентами ([Мультииндекс](https://github.com/ThinkingFrog/IVector/blob/main/include/IMultiIndex.h)), который задаёт число разбиений сетки по каждой оси.

Замечания по интерфейсу:
- получение ресурса аналогично `ISet`: имеется 2 варианта по семантике получения ресурса
- деструктор чисто виртуальный намеренно, аналогично `IVector`
- метод `createCompactSpan` создаёт наименьший компакт, содержащий переданные 2 компакта
- конкретный узел сетки можно получить передав в соответствующий метод (`getVectorzCopy` или `getVectorCoords`) мультииндекс этого узла

## IProblem, IDiffProblem

[Интерфейс целевой фукнции](https://github.com/ThinkingFrog/IVector/blob/main/include/IProblem.h) и [дифференцируемой целевой фукнции](https://github.com/ThinkingFrog/IVector/blob/main/include/IDiffProblem.h).

Определяется двумя компактами: область определения аргумента и подмножество параметрического пространства.

Замечания по интерфейсу:
- значения функции и её производные вычисляются в 2 этапа: фиксируется методом `set...` параметры или аргументы, затем вычисляется значение или производная по параметру или аргументу
- метод `derivativeBy...` вычисляет частную производную по аргументу. Частная производная определяется по мультииндексу (сколько раз по какой оси брать производную)
